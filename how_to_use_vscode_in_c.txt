Visual studio code는 IDE가 아니라, 텍스트 에디터이기 때문에 개발 환경 설정이 좀 복잡하다. 
그중에서 핵심이 되는 내용을 정리하였다. 
Tony0329taehoon 유튜브 내 채널에 비공개로, 맥북 초기 설정과 vscode 튜토리얼 동영상이 있다. 
Vscode 설치, 컴파일러 설치, 환경변수 설정은 인터넷 보고 잘 해준다. 

0: visual studio 공식 문서를 확인한다.
 https://code.visualstudio.com/docs
맨 위에 topics 메뉴 선택칸을 클릭하면 모든 토픽들이 다 나온다. 

1: 기본 bash 명령어를 숙지한다. (터미널로도 작업이 가능)
C 소스 파일을 터미널에서 직접 컴파일 → 실행 → 링킹 하는 과정을 기본 bash 명령어와 함께 차례대로 정리해드릴게요.
mkdir my_c_project      # 새 프로젝트 폴더 만들기
cd my_c_project         # 폴더로 이동
code hello.c            # VS Code로 hello.c 파일 열기

Hello.c 파일을 작성할때 맨위에 줄에 주석으로 파일이름을 명시해야한다. // hello.c 처럼 

gcc hello.c -o hello    # hello.c를 컴파일해서 실행 파일 hello 생성
./hello 			# hello 실행

아래와 같은 파일구조가 있다면 
my_c_project/
├─ main.c
├─ func.c
└─ func.h

gcc -c main.c   # main.o 생성
gcc -c func.c   # func.o 생성
gcc main.o func.o -o my_program
./my_program

또는 
gcc main.c func.c -o my_program
./my_program

* `-Wall` : 경고 메시지 활성화
* `-g` : 디버깅 정보 포함 (gdb 디버깅용)
* `-O2` : 최적화
gcc -Wall -g main.c func.c -o my_program

그리고 상대경로로 명시한 파일이나, 절대경로 명시 파일이 아니라면 환경변수의 path 항목의 디렉토리를 차례로 찾아가면서 해당 프로그램명을 찾는다. 즉 clang hello.c -o hello라고  내 document 디렉토리에서 명령해서 해당 경로에 clang 파일이 없어도 알아서 /usr/bin/clang을 실행해준다.   

특정 프로그램을 실행할때 ./hello abc 123 456 이라고 입력하면 첫번째 인자가 ./hello, 두번째 인자가 abc, 세번째 인자가 123, 네번째 인자가 456이다. 



2: C/C++ 언어에서의 vscode 사용법
Vscode 에서 code . 로 원하는 디렉토리를 루트폴더로 만든다. Explorer 에서 hello.c 파일을 만든다. C 소스 코드를 치고, f5(디버깅), ctrl + f5 (디버깅 안하고 실행)을 하면 디버거를 선택하라는 메뉴가 뜨는데 C++ (gdb/lldb)를 선택하면, C/C++: clang build active file 이라는 레이블을 가진 tasks.json 파일을 선택할거냐고 뜨는데 선택해준다. 그럼 root/.vscode/tasks.json 파일에 clang 파일을 이용해서 빌드를 해주는 스크립트 json 파일이 만들어진다. 참고로 clang이 C 컴파일러이고 clang++가 C++ 컴파일러이다. 두 개는 다른것이다. 윈도우, 리눅스에서는 gcc, g++를 자주 쓴다. 

3: Json 파일에 대한 설명
JSON은 JavaScript Object Notation의 약자로, 데이터를 저장하고 교환하기 위한 경량의 텍스트 기반 형식입니다. 사람과 기계 모두 읽기 쉽도록 설계되었으며, 웹 애플리케이션에서 서버와 클라이언트 간에 데이터를 주고받을 때 가장 널리 사용됩니다.

JSON 파일의 기본 구조
JSON 파일은 기본적으로 두 가지 구조로 이루어져 있습니다.

키-값 쌍(Key-Value Pair): 중괄호 {} 안에 데이터를 객체 형태로 저장합니다. 각 데이터는 "키"와 "값"이 쌍을 이루며, 콜론 :으로 구분됩니다. 여러 쌍은 쉼표 ,로 구분합니다. 키는 항상 큰따옴표 "로 묶인 문자열이어야 합니다. 값은 문자열, 숫자, 불리언(true/false), 배열, 객체 또는 null이 될 수 있습니다.

배열(Array): 대괄호 [] 안에 값들을 순서대로 저장합니다. 값들은 쉼표 ,로 구분됩니다. 배열은 여러 개의 객체를 담는 데 자주 사용됩니다.

JSON 데이터 타입
JSON에서 사용할 수 있는 값의 타입은 다음과 같습니다.

문자열(String): 큰따옴표 "로 묶인 텍스트입니다. 예: "name": "김철수"

숫자(Number): 정수 또는 실수입니다. 예: "age": 30, "price": 19.99

객체(Object): 중괄호 {} 안에 여러 키-값 쌍을 포함하는 구조입니다.

배열(Array): 대괄호 [] 안에 순서가 있는 값들의 목록입니다.

불리언(Boolean): true 또는 false 값입니다. 예: "is_student": true

Null: 값이 없음을 나타냅니다. 예: "middle_name": null

JSON 파일의 장점
경량성: XML에 비해 파일 크기가 작아 데이터 전송 속도가 빠릅니다.

가독성: 사람 눈으로도 쉽게 읽고 이해할 수 있는 구조입니다.

상호 운용성: 거의 모든 프로그래밍 언어에서 JSON을 파싱(parsing)하고 생성하는 기능을 지원합니다.

유연성: 데이터 스키마가 엄격하지 않아 필요한 데이터만 유연하게 주고받을 수 있습니다.

이러한 특성 덕분에 JSON은 웹 API(애플리케이션 프로그래밍 인터페이스)를 통해 데이터를 주고받거나, 설정 파일을 만들거나, NoSQL 데이터베이스에 데이터를 저장하는 등 다양한 분야에서 활용됩니다.

4: tasks.json 파일 분석 
하단은 ctrl + f5 실행으로 기본적으로 생성되는 tasks.json 파일이다. Vscode에서 빌드만 해주는 json 설정 스크립트이다. 
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: clang build active file",
            "command": "/usr/bin/clang",
            "args": [
                "-fcolor-diagnostics",
                "-fansi-escape-codes",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
} 

제공된 JSON 파일은 VS Code의 tasks.json 파일 구조와 매우 유사합니다. 이 파일은 특정 작업을 자동화하고 실행하기 위한 설정을 정의합니다. 아래에서 각 요소를 자세히 분석해 드리겠습니다.

최상위 요소
"tasks": 이 JSON 파일의 핵심 부분으로, 배열입니다. 배열 안에는 하나 이상의 작업(task) 객체가 포함될 수 있습니다. 현재 파일에는 하나의 작업 객체만 있습니다.

"version": 파일의 스키마 버전을 나타냅니다. 현재 버전은 2.0.0입니다.

"tasks" 배열 내부의 객체 분석
배열 내부의 단일 객체는 하나의 특정 작업을 정의합니다.

"type": "cppbuild": 작업의 유형을 나타냅니다. cppbuild는 C/C++ 코드 빌드 작업임을 명시합니다. 이는 VS Code의 C/C++ 확장 프로그램에서 사용하는 고유한 유형입니다.

"label": "C/C++: clang build active file": VS Code의 터미널이나 작업 목록에서 사용자가 이 작업을 쉽게 식별할 수 있도록 붙여진 이름입니다.

"command": "/usr/bin/clang": 실행할 명령어의 경로입니다. 이 경로는 시스템에 설치된 clang 컴파일러의 위치를 가리킵니다.

"args": 명령어와 함께 전달될 **인자(argument)**들의 배열입니다.

"-fcolor-diagnostics": 컴파일러가 출력하는 진단 메시지(예: 경고, 오류)에 색상을 입힙니다.

"-fansi-escape-codes": ANSI 이스케이프 코드를 사용하여 텍스트 서식을 제어합니다.

"-g": 디버깅 정보를 포함하여 실행 파일을 생성합니다. 이는 디버거가 소스 코드를 추적하는 데 필수적인 옵션입니다.

"${file}": VS Code에서 현재 활성화된(열려 있는) 파일의 전체 경로를 나타내는 변수입니다. 즉, 현재 작업 중인 파일을 컴파일합니다.

"-o": 출력 파일의 이름을 지정하는 옵션입니다.

"${fileDirname}/${fileBasenameNoExtension}": 출력될 실행 파일의 경로와 이름입니다. 이는 현재 파일이 있는 디렉터리에 현재 파일명에서 확장자(.c 또는 .cpp)를 제외한 이름으로 실행 파일을 생성하라는 의미입니다.

"options": 명령어 실행에 대한 추가 옵션을 정의하는 객체입니다.

"cwd": "${fileDirname}": current working directory, 즉 작업이 실행될 현재 디렉터리를 지정합니다. "${fileDirname}"은 현재 활성화된 파일이 있는 디렉터리를 의미합니다.

"problemMatcher": ["$gcc"]: 컴파일러의 출력에서 에러나 경고를 인식하고 VS Code의 "문제" 탭에 표시하는 데 사용되는 패턴입니다. $gcc는 gcc 컴파일러의 표준 출력 형식을 인식하는 내장 패턴입니다. clang이 gcc와 비슷한 출력 형식을 사용하기 때문에 이 패턴이 사용됩니다.

"group": 이 작업이 속한 그룹을 정의하는 객체입니다.

"kind": "build": 이 작업이 빌드 작업임을 나타냅니다.

"isDefault": true: 이 빌드 그룹의 기본 작업으로 지정됩니다. 사용자가 Ctrl+Shift+B (Windows/Linux) 또는 Cmd+Shift+B (macOS)와 같은 단축키를 눌렀을 때 이 작업이 자동으로 실행됩니다.

"detail": "Task generated by Debugger.": 사용자를 위한 추가적인 설명입니다. 이 작업이 디버거에 의해 자동으로 생성되었음을 알려줍니다.

5: vscode에서 빌드, 디버깅, 디버깅하지 않고 실행의 단축키

VS Code에서 C/C++ 프로젝트를 빌드하고 실행하는 데 사용되는 기본 단축키는 다음과 같습니다.

빌드 관련 단축키
빌드 작업 실행 (tasks.json 파일에 설정된 기본 빌드 작업):

Windows / Linux: Ctrl + Shift + B

macOS: Cmd + Shift + B

이 단축키는 tasks.json 파일에 isDefault: true로 설정된 빌드 작업을 실행합니다. 위에서 분석했던 JSON 파일처럼 clang 컴파일러를 사용해 코드를 빌드할 때 주로 사용됩니다.

디버깅 관련 단축키
디버깅 시작:

Windows / Linux: F5

macOS: F5

이 단축키는 코드에 설정된 중단점(breakpoint)에서 프로그램을 일시 정지시키고, 디버깅을 시작합니다. launch.json 파일에 설정된 내용에 따라 실행됩니다.

디버깅 중지:

Windows / Linux: Shift + F5

macOS: Shift + F5

실행 중인 디버깅 세션을 즉시 종료합니다.

한 단계씩 코드 실행 (Step Over):

Windows / Linux: F10

macOS: F10

함수 내부로 들어가지 않고, 현재 줄의 다음 줄로 이동하며 코드를 실행합니다.

함수 안으로 들어가기 (Step Into):

Windows / Linux: F11

macOS: F11

현재 줄에 있는 함수가 있다면 그 함수 내부로 들어가서 코드를 실행합니다.

디버깅하지 않고 실행 (Run Without Debugging)
디버깅 없이 실행:

Windows / Linux: Ctrl + F5

macOS: Cmd + F5

디버거를 연결하지 않고, 프로그램을 일반적인 상태로 실행합니다. 코드가 정상적으로 작동하는지 빠르게 확인하고 싶을 때 유용합니다.

VS Code의 단축키는 설정에 따라 변경될 수 있으므로, 만약 위 단축키가 작동하지 않는다면 파일(File) > 기본 설정(Preferences) > 바로 가기 키(Keyboard Shortcuts) 메뉴에서 현재 설정된 단축키를 확인하고 수정할 수 있습니다.

6: 저 3개의 단축키는 어떤 json 파일을 실행시키는 것인가? 

Ctrl+Shift+B (Build Task)
이 단축키는 tasks.json 파일에 정의된 빌드 작업을 실행합니다. 이 작업은 컴파일러를 호출하여 소스 코드를 실행 가능한 파일로 만드는 역할을 합니다. 이 단축키는 tasks.json 파일의 내용을 기반으로 하며, 특히 group 내에 "isDefault": true로 설정된 작업을 찾아 실행합니다.

F5 (Start Debugging)
이 단축키는 디버깅을 시작합니다. 이때는 tasks.json이 아니라, launch.json 파일에 정의된 설정을 기반으로 합니다. launch.json은 프로그램의 실행 환경, 디버거 연결 방식, 디버깅 시 전달할 인수 등을 상세하게 정의하는 파일입니다. 경우에 따라 launch.json에서 디버깅 시작 전에 특정 빌드 작업을 먼저 실행하도록 설정할 수 있습니다. 예를 들어, "preLaunchTask" 옵션을 사용하여 tasks.json의 빌드 작업을 연결할 수 있습니다.

Ctrl+F5 (Run Without Debugging)
이 단축키는 디버거를 연결하지 않고 프로그램을 실행합니다. 이 역시 기본적으로는 launch.json 파일에 정의된 실행 설정을 따릅니다. 디버깅에 필요한 추가적인 설정(예: 중단점) 없이 단순히 프로그램을 빠르게 실행하는 용도로 사용됩니다. 이 경우에도 launch.json의 preLaunchTask를 통해 빌드 작업을 먼저 실행하도록 구성할 수 있습니다.

7: 디버깅하지 않고 실행, 디버깅시에 launch.json 파일 만들기 
F5, ctrl+f5 로 디버깅, 실행하려면 launch.json 파일을 만들어야 한다. (없으면 자동으로 vscode가 디폴트 디버깅) 오른쪽 상단의 플레이/벌레 아이콘 오른쪽에 톱니바퀴 설정 버튼을 누르면 select a debug configuration이 뜨는데, C/C++: clang build and debug active file을 클릭해서 해당 이름을 가진 launch.json을 만들면 된다. 또는 그냥 자기가 .vscode 폴더에 launch.json을 수동으로 만들어도 된다. 

8: launch.json 파일 분석 
{
    "configurations": [
        {
            "name": "C/C++: clang build and debug active file",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": true,
            "MIMode": "lldb",
            "preLaunchTask": "C/C++: clang build active file"
        }
    ],
    "version": "2.0.0"
}

이 JSON 파일은 VS Code에서 디버깅 설정을 정의하는 launch.json 파일입니다. 이 파일은 F5 키를 눌렀을 때 VS Code가 어떻게 프로그램을 실행하고 디버깅할지 알려줍니다.

주요 요소 분석
configurations: 디버깅 설정을 담고 있는 배열입니다. 하나의 프로젝트에 여러 개의 디버깅 설정을 만들 수 있습니다. 현재는 하나의 설정만 정의되어 있습니다.

name: "C/C++: clang build and debug active file"

VS Code의 디버그 메뉴에서 이 설정을 식별하는 이름입니다.

type: "cppdbg"

사용할 디버거의 종류를 지정합니다. cppdbg는 C/C++ 디버깅에 사용되는 확장 기능을 나타냅니다.

request: "launch"

디버거의 동작 방식입니다. launch는 프로그램을 실행하고 디버거를 연결하라는 의미입니다. (반대로 이미 실행 중인 프로세스에 디버거를 연결하려면 attach를 사용합니다.)

program: "fileDirname/{fileBasenameNoExtension}"

디버깅할 실행 파일의 경로를 지정합니다. tasks.json과 동일하게, 현재 열려 있는 파일의 디렉터리에 확장자가 제거된 파일명을 가진 실행 파일을 찾습니다.

args: []

실행 파일에 전달할 명령줄 인수(argument)들의 배열입니다. 현재는 빈 배열이므로 인수가 전달되지 않습니다.

stopAtEntry: false

프로그램 시작 지점(예: main 함수)에서 자동으로 멈출지 여부를 설정합니다. false이므로 자동으로 멈추지 않습니다.

cwd: "${fileDirname}"

프로그램이 실행될 작업 디렉터리(Current Working Directory)를 지정합니다. 현재 파일이 있는 디렉터리로 설정되어 있습니다.

environment: []

프로그램 실행 시 설정할 환경 변수들의 배열입니다. 현재는 빈 배열이므로 별도의 환경 변수 설정은 없습니다.

externalConsole: true

디버깅 콘솔을 VS Code 내부 터미널이 아닌 별도의 외부 창에 띄울지 여부를 결정합니다. true로 설정되어 외부 콘솔이 사용됩니다.

MIMode: "lldb"

사용할 디버거 엔진을 지정합니다. lldb는 LLVM 프로젝트의 디버거로, clang 컴파일러와 잘 호환됩니다. (Windows에서는 주로 gdb가 사용됩니다.)

preLaunchTask: "C/C++: clang build active file"

디버깅을 시작하기 전에 먼저 실행할 작업의 이름을 지정합니다. 이 이름은 이전에 분석했던 tasks.json 파일의 label 값과 일치해야 합니다. 이 설정 덕분에 F5 키를 누르면 자동으로 clang 컴파일러가 코드를 빌드하고, 그 후에 빌드된 실행 파일에 디버거가 연결됩니다.

version: "2.0.0"

파일의 스키마 버전을 나타냅니다.

macOS에서는 내부 터미널로 설정하면 디버깅시 출력물이 안뜨는 문제가 있으므로 externalConsole을 true로 설정해야한다. 윈도우나 리눅스에서는 내부 터미널로 해도 된다. 

9: vs code의 워크스페이스 설정
VS Code의 워크스페이스 설정은 기본적으로 **현재 열린 폴더(루트 폴더)**를 기준으로 적용됩니다.

VS Code 설정 적용 규칙
VS Code는 설정을 적용할 때 다음과 같은 계층적 우선순위를 따릅니다.

사용자 설정 (User Settings): VS Code를 사용하는 모든 프로젝트에 적용되는 전역 설정입니다. settings.json 파일은 보통 사용자 프로필 폴더에 저장됩니다.

워크스페이스 설정 (Workspace Settings): 현재 열려 있는 루트 폴더 내의 .vscode/settings.json 파일에 정의된 설정입니다. 이 설정은 사용자 설정을 덮어씁니다.

따라서, 사용자가 언급하신 상황을 보면:

root 폴더를 열었을 때: VS Code는 root/.vscode/settings.json 파일을 찾아 이 폴더와 그 아래의 모든 하위 폴더에 설정을 적용합니다. 이때 root/C1/.vscode/settings.json 파일이 존재하더라도, root 폴더가 워크스페이스의 루트이므로 해당 설정은 자동으로 적용되지 않습니다.

C1 폴더를 별도의 VS Code 창으로 열었을 때: 이 경우에는 C1이 워크스페이스의 루트 폴더가 됩니다. 따라서 VS Code는 C1/.vscode/settings.json 파일을 찾아 해당 폴더와 그 아래에 설정을 적용합니다. 이 설정이 root 폴더의 설정보다 우선시됩니다.

이러한 방식은 여러 프로젝트가 포함된 큰 저장소에서 각 하위 프로젝트마다 고유한 개발 환경을 유지하도록 돕습니다. 특정 하위 프로젝트를 작업할 때는 해당 폴더를 워크스페이스로 열어야만 그에 맞는 설정을 확실하게 적용할 수 있습니다.

10: format 설정하기
Clang-format 확장 프로그램을 설치하고, Vscode의 설정에서 format을 검색해서 format on save를 활성화, default formatter 를 clang-format으로 설정하면 된다. 그러면 소스 파일이 저장될때 자동으로 포맷팅해준다. 

11: C/C++ 프로젝트의 디렉토리 설정 
C 프로젝트에서 CMake를 사용할 때, 일반적인 디렉토리 구성은 코드의 가독성, 관리, 그리고 재사용성을 높이는 데 초점을 맞춥니다.

기본 디렉터리 구조
일반적으로 C 프로젝트의 디렉터리는 다음과 같이 구성됩니다.

project_root/
├── src/
│   ├── main.c
│   ├── module1.c
│   └── module2.c
├── include/
│   └── module1.h
├── lib/
│   └── (외부 라이브러리)
├── test/
│   └── test_module1.c
├── build/
└── CMakeLists.txt
주요 디렉터리 및 파일 설명
project_root/: 프로젝트의 최상위 디렉터리입니다. 이곳에 전체 프로젝트를 관리하는 최상위 CMakeLists.txt 파일이 위치합니다.

src/: 프로젝트의 **소스 코드 파일(.c)**을 저장하는 곳입니다. main.c와 같이 실행 가능한 프로그램의 핵심 파일들이 이 디렉터리에 위치합니다.

include/: **헤더 파일(.h)**을 모아두는 곳입니다. 이 디렉터리에 있는 헤더 파일들은 프로젝트 내의 다른 소스 파일들이나 외부 프로젝트에서 참조할 수 있도록 공개됩니다. 이 방식을 사용하면 소스 코드와 헤더 파일의 분리가 명확해져 유지보수가 쉬워집니다.

lib/: 프로젝트가 의존하는 외부 라이브러리를 보관하는 곳입니다. 보통 이 디렉터리에 직접 라이브러리 파일을 복사하거나, CMake의 find_package()와 같은 명령을 사용하여 시스템에 설치된 라이브러리를 찾는 방식을 사용합니다.

test/: 프로젝트의 단위 테스트 코드를 저장하는 곳입니다. CTest와 같은 테스트 프레임워크와 함께 사용하여 빌드 프로세스에 테스트를 통합할 수 있습니다.

build/: 컴파일 과정에서 생성되는 파일들을 모아두는 곳입니다. 실행 파일, 오브젝트 파일, 그리고 CMakeCache.txt와 같은 CMake 관련 파일들이 이곳에 생성됩니다. 소스 코드와 빌드 결과물을 분리함으로써 깔끔한 프로젝트 구조를 유지할 수 있습니다.

CMakeLists.txt: CMake가 빌드 파일을 생성하는 데 사용하는 스크립트 파일입니다. 이 파일에 소스 파일, 헤더 파일의 경로, 라이브러리 의존성, 빌드 옵션 등을 정의합니다.

이점
이러한 디렉터리 구조는 모듈성과 확장성을 크게 향상시킵니다. 예를 들어, module1의 소스 코드는 src/에, 다른 파일에서 재사용할 헤더 파일은 include/에 분리하여 저장함으로써 코드를 명확하게 관리할 수 있습니다. 또한 build 디렉토리를 별도로 두어 소스 코드가 지저분해지는 것을 막을 수 있습니다.

12: cmake로 빌드 자동화하기 
VS Code에서 CMake를 쓴다는 건, C/C++ 프로젝트를 빌드하기 위해 CMake라는 빌드 시스템을 VS Code와 연동해서 쓰는 걸 말해요. 차근차근 설명드릴게요.

1. CMake란?

목적: 여러 운영체제/컴파일러에서 공통적으로 쓸 수 있는 빌드 스크립트를 만들어주는 툴.

원리: CMakeLists.txt 파일에 프로젝트 설정(소스 파일, 라이브러리, 컴파일 옵션 등)을 작성 → CMake가 각 플랫폼에 맞는 빌드 파일(예: Makefile, Ninja, Visual Studio 솔루션 등)을 생성 → 빌드 툴이 실행.

즉, CMake는 **“메타 빌드 시스템”**이에요.
(개발자가 직접 Makefile을 쓰지 않고, CMake가 대신 만들어줌.)

2. VS Code에서 CMake 사용하려면

확장 프로그램 설치

CMake Tools (Microsoft 공식)

C/C++ (IntelliSense, 디버깅 지원)

CMake 설치

시스템에 cmake를 설치해야 함 (Windows: winget install cmake, Linux: sudo apt install cmake, macOS: brew install cmake)

프로젝트 구조
보통 이런 식:

MyProject/
├─ src/
│   └─ main.cpp
├─ CMakeLists.txt


CMakeLists.txt 예시

cmake_minimum_required(VERSION 3.10)
project(MyProject)
set(CMAKE_CXX_STANDARD 17)
add_executable(my_app src/main.cpp)


VS Code에서 실행

Ctrl+Shift+P → CMake: Configure

빌드할 컴파일러/툴체인 선택

Ctrl+Shift+P → CMake: Build

결과물(my_app) 실행

3. VS Code + CMake의 장점

크로스 플랫폼 (Linux/Windows/macOS 전부 동일)

GUI 없이 깔끔하게 VS Code 안에서 빌드/실행 가능

디버깅 환경까지 쉽게 연동 가능

Vscode의 왼쪽 메뉴 아이콘에서 cmake로 들어가면 왼쪽에 project status 항목이 있는데, 여기서 configure 오른쪽 설정 버튼을 눌러서 추천되는 설정을 잘 해주고, build, test, debug, launch 오른쪽의 버튼을 클릭해서 각각 실행해주면 된다. Build를 하면 build 폴더에서 실행파일을 빌드해주고, debug와 launch를 해주면 각각 디버깅, 실행을 해준다. 이 gui 환경에서 실행을 하면 .vscode의 launch.json 을 실행시키지 않는다. 그리고 소스파일이 추가되거나 변경되면, configure과 빌드를 다시 해주어야 한다. 자동으로 적용이 되지 않기 때문이다. 

그런데 문제는 f5, ctrl+f5, cmd + shift + b 등의 디버깅, 실행, 빌드 단축키를 누르면 vscode 내장된 .json 파일을 생성해서 실행이 되기 때문에 cmake의 gui로 실행할때랑 환경이 달라진다. 따라서 launch.json 파일과 tasks.json 파일을 잘 만들어서 자동으로 cmake로 빌드를 해줄 수 있도록 설정하는게 편하다. 


13: Cmake 내부 명령어 분석 
CMake와 관련된 핵심 명령어는 프로젝트 설정, 빌드, 설치를 담당하는 명령어들로 구성됩니다. 이 명령어들을 통해 복잡한 빌드 과정을 자동화하고 다양한 환경에서 일관된 빌드를 가능하게 합니다.

프로젝트 설정
cmake_minimum_required(VERSION version_number)
CMake를 사용하기 위해 필요한 최소 버전을 명시합니다. 이는 스크립트의 호환성을 보장하는 데 필수적입니다.

project(project_name)
프로젝트의 이름을 정의합니다. 이 명령어는 프로젝트의 루트 디렉토리에 있는 CMakeLists.txt 파일에 주로 사용됩니다.

add_executable(target_name source1 source2 ...)
지정된 소스 파일들로 실행 파일을 생성하는 명령어입니다. target_name은 빌드 시스템에서 사용될 실행 파일의 이름입니다.

file(GLOB SOURCES “src./*.c”)
add_executable(my_program ${SOURCES})
src 폴더에서 모든 .c 파일을 자동으로 찾아서 add_executable에 넘기는 방법!
주의) .c 파일이 변경되면 cmake를 다시 configure, build 해서 업데이트 해야한다. 

add_library(target_name [STATIC | SHARED | MODULE] source1 source2 ...)
지정된 소스 파일들로 라이브러리를 생성합니다. STATIC은 정적 라이브러리(.lib, .a), SHARED는 동적 라이브러리(.dll, .so), MODULE은 플러그인과 같은 모듈 라이브러리를 만듭니다.

종속성 및 경로 설정
target_link_libraries(target_name library1 library2 ...)
특정 타겟(실행 파일 또는 라이브러리)이 의존하는 라이브러리들을 연결합니다.

include_directories(directory1 directory2 ...)
헤더 파일을 찾을 경로를 추가합니다. 이 경로는 프로젝트 전체에 적용됩니다.

target_include_directories(target_name [PUBLIC | PRIVATE | INTERFACE] directory1 ...)
특정 타겟에만 헤더 파일 경로를 추가합니다. PUBLIC은 타겟과 의존성 타겟 모두에 경로를 추가하고, PRIVATE은 타겟에만, INTERFACE는 의존성 타겟에만 경로를 추가합니다.

find_package(PackageName [VERSION] [REQUIRED | QUIET])
다른 패키지나 라이브러리를 찾습니다. 이 명령어를 통해 외부 라이브러리의 헤더 파일과 라이브러리 경로를 쉽게 가져올 수 있습니다.

빌드 및 설치
set(VARIABLE value)
변수를 설정하는 명령어입니다. 예를 들어, set(CMAKE_CXX_STANDARD 17)는 C++ 표준을 17로 설정합니다.

install(TARGETS target1 target2 ... DESTINATION path)
빌드된 타겟(실행 파일, 라이브러리 등)을 특정 경로에 설치합니다. 이 명령어는 make install 또는 cmake --install 명령을 실행할 때 사용됩니다.

message([STATUS | WARNING | FATAL_ERROR] "message string")
사용자에게 메시지를 출력합니다. 빌드 과정의 진행 상황을 알리거나, 경고, 오류 메시지를 표시하는 데 유용합니다.

나의 예시 CMakeLists.txt는 
cmake_minimum_required(VERSION 3.10)
project(Modoo1 C)
set(CMAKE_C_STANDARD 99)
include_directories(include)
add_executable(Modoo1 src/main.c src/printHello.c)
이다. 
Cmake version 을 3.10을 쓰고, project 이름은 Modoo1 이고 C 언어를 사용한다. C 표준은 C99를 사용하고, include 경로를 include 폴더로 설정한다. 실행파일의 이름은 Modoo1이고, src/main.c와 src/printHello.c를 소스코드로 사용한다. 

14. Cmake 외부 명령어 분석
핵심 CMake 명령어는 프로젝트 구성, 빌드, 설치의 세 가지 주요 단계로 나눌 수 있습니다.
프로젝트 구성

cmake: 이 명령어는 프로젝트의 최상위 소스 디렉토리에서 실행됩니다. 빌드 시스템(예: Makefile 또는 Visual Studio 솔루션)을 생성하는 역할을 합니다. 일반적으로 cmake -S <source_dir> -B <build_dir> 형태로 사용합니다. -S는 소스 코드가 있는 디렉토리를, -B는 빌드 결과물이 저장될 디렉토리를 지정합니다.
cmake --preset <preset_name>: CMakePresets.json 파일에 정의된 사전 설정(preset)을 사용하여 프로젝트를 구성합니다. 이 명령어는 복잡한 구성 옵션을 단순화하고 팀원 간에 일관된 빌드 환경을 공유하는 데 유용합니다.
빌드

cmake --build <dir>: CMake가 생성한 빌드 시스템을 호출하여 프로젝트를 컴파일하고 링크합니다. 이 명령어는 사용 중인 제너레이터에 관계없이 동일한 방식으로 빌드를 시작할 수 있게 해주는 추상화된 방법입니다.
cmake --build <dir> --target <target_name>: 전체 프로젝트를 빌드하는 대신, add_executable()이나 add_library()로 정의한 특정 타겟만 빌드합니다.
cmake --build <dir> --config <configuration>: 다중 구성 제너레이터(예: Visual Studio)를 사용할 때 Debug, Release 등과 같은 특정 빌드 구성을 지정합니다.
설치

cmake --install <dir>: CMakeLists.txt 파일에 install() 명령어로 정의된 규칙에 따라 빌드된 실행 파일, 라이브러리, 헤더 파일 등을 지정된 위치에 복사합니다. 이 명령어는 make install과 같은 역할을 수행합니다.
이 명령어들을 통해 개발자는 소스 코드에서 실행 가능한 프로그램이나 라이브러리를 만들고, 이를 시스템에 배포하는 전체 과정을 일관되고 자동화된 방식으로 처리할 수 있습니다.

15. cmake를 .json 파일로 어떻게 f5 한번으로 빌드, 실행, 디버깅 되게 하는 방법 
.vscode 디렉터리에 **tasks.json**과 launch.json 파일을 직접 설정하여 Visual Studio Code에서 CMake 프로젝트를 빌드하고 디버깅하는 방법을 단계별로 정리해 드리겠습니다.

1단계: 빌드 작업 정의 (tasks.json)
tasks.json 파일은 프로젝트를 빌드하는 작업을 정의합니다. F5를 누를 때마다 이 작업이 자동으로 실행되어 최신 코드로 빌드되도록 설정할 수 있습니다.
JSON
// .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build my_program",
      "type": "shell",
      "command": "cmake --build build",
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": []
    }
  ]
}


label: 빌드 작업의 이름입니다. 이 이름은 launch.json 파일에서 참조됩니다.
command: cmake --build build는 build 디렉터리에서 빌드를 실행하라는 의미입니다. build 폴더명이 다르다면 해당 이름으로 바꿔야 합니다.
group.isDefault: true로 설정하면 기본 빌드 작업으로 지정됩니다.

2단계: 디버깅 설정 (launch.json)
launch.json 파일은 디버깅을 시작할 때 실행할 프로그램과 디버거 설정을 정의합니다. 이 파일은 tasks.json의 빌드 작업을 참조하여 디버깅 전에 자동으로 빌드하도록 연결해줍니다.
JSON
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug my_program",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/build/my_program",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": true,
      "MIMode": "lldb", // macOS인 경우 "lldb", Windows는 "gdb" 또는 "cppvsdbg"
      "preLaunchTask": "build my_program"
    }
  ]
}


name: 디버깅 구성의 이름입니다. VS Code의 실행 및 디버그 뷰에서 이 이름으로 표시됩니다.
program: 디버깅할 실행 파일의 경로입니다. ${workspaceFolder}는 현재 프로젝트의 루트 폴더를 나타냅니다. build/my_program 경로가 실제로 존재하는지 확인해야 합니다.
MIMode: 사용할 디버거 엔진을 지정합니다. macOS는 lldb, Windows는 cppvsdbg, Linux는 gdb가 일반적입니다.
preLaunchTask: 디버깅 전에 실행할 작업의 레이블을 지정합니다. 여기서는 1단계에서 정의한 build my_program 작업을 참조하여 자동으로 빌드가 실행되도록 합니다.

사용 방법 및 팁
F5 키: launch.json에 정의된 대로 preLaunchTask를 실행한 다음, 지정된 프로그램을 디버거와 함께 실행합니다.
Ctrl+F5 키: 디버거를 연결하지 않고 프로그램을 실행합니다. (빠른 실행)
디버깅이 제대로 작동하지 않을 때 점검 사항
디버그 심볼 활성화: 실행 파일에 디버깅 정보가 포함되도록 CMakeLists.txt에 set(CMAKE_BUILD_TYPE Debug)를 추가해야 합니다.
디버거 설치: MIMode에 맞는 디버거(gdb 또는 lldb)가 시스템에 설치되어 있어야 합니다.
경로 확인: program 경로가 올바르게 지정되었는지, 빌드된 실행 파일이 해당 위치에 있는지 확인해야 합니다.
이러한 설정으로 Visual Studio Code에서 F5 키만 눌러도 프로젝트 빌드부터 디버깅까지 한 번에 처리할 수 있습니다.
16. Makefile 사용방법 
Makefile은 소프트웨어 빌드 과정을 자동화하는 데 사용되는 파일입니다. 간단히 말해, 어떤 파일을 만들려면 어떤 작업이 필요한지 기술하는 규칙들의 모음입니다. 특히 C, C++ 같은 컴파일 언어의 소스 코드를 실행 파일로 만드는 복잡한 과정을 효율적으로 관리합니다.

Makefile의 작동 원리
Makefile은 기본적으로 **규칙(rule)**으로 구성됩니다. 각 규칙은 다음의 세 가지 요소로 이루어집니다.
타겟(Target): 만들어야 할 최종 파일(예: 실행 파일) 또는 수행해야 할 작업의 이름입니다.
종속성(Dependencies): 타겟을 만들기 위해 필요한 파일들(예: 소스 코드, 헤더 파일)입니다.
명령어(Commands): 종속성을 이용해 타겟을 만드는 데 필요한 실제 명령어(예: 컴파일 명령어)입니다. 명령어는 반드시 탭 문자로 시작해야 합니다.
간단한 예시는 다음과 같습니다.
Makefile
my_program: main.o file1.o
    g++ -o my_program main.o file1.o

main.o: main.cpp
    g++ -c main.cpp

file1.o: file1.cpp
    g++ -c file1.cpp


위 Makefile을 사용하면, 터미널에서 make my_program을 실행했을 때 make는 다음과 같은 과정을 거칩니다.
my_program 타겟을 찾습니다.
my_program의 종속성인 main.o와 file1.o가 존재하는지 확인합니다.
main.o가 없으면 main.o 타겟을 찾아 main.cpp를 컴파일하는 명령을 실행합니다.
file1.o가 없으면 file1.o 타겟을 찾아 file1.cpp를 컴파일하는 명령을 실행합니다.
main.o와 file1.o가 모두 만들어지면, 최종적으로 my_program을 만드는 링킹 명령을 실행합니다.

Makefile의 장점
자동화: 복잡한 컴파일, 링크 과정을 한 번의 명령으로 처리합니다.
효율성: 변경된 소스 파일만 재컴파일하여 시간을 절약합니다. 예를 들어, file1.cpp만 수정하면 main.o는 다시 컴파일하지 않고 file1.o만 새로 만든 뒤 최종 링킹만 다시 합니다.
재사용성: 동일한 빌드 과정을 반복적으로 적용할 수 있습니다.
이식성: 시스템의 make 도구에 의존하므로, Unix/Linux 기반 시스템에서 널리 사용됩니다.
Makefile은 컴파일 환경과 의존성을 직접 기술해야 하는 단점이 있지만, 그 유연성과 강력함 때문에 여전히 많은 프로젝트에서 중요한 빌드 도구로 사용됩니다.
Makefile의 여러 추가 문법들은 ai 로 그때 그때 확인한다. Makefile은 만들기가 복잡하니까, cmake 사용을 강력 추천한다. 
이상으로 vscode에서 C/C++ 사용 방법이었다. 






